# 

# 4_Linux进程控制

## 进程创建

### fork创建子进程做了什么？

进程 = 内核数据结构 + 进程的代码和数据 => 内核数据结构是操作系统创建的。而进程的代码和数据，一般是从磁盘中加载到内存而来。=> fork创建子进程，由操作系统为子进程创建对应的内核数据结构：PCB，进程地址空间对象，页表等。虽然子进程内核数据结构中的大部分数据是从父进程那里拷贝来的，但是因为进程的独立性，这部分内核数据结构确实是子进程独有的。=> 而子进程对应的代码和数据，并不是从磁盘中加载而来。而是直接和父进程”共享一份代码和数据“，可是，基于进程的独立性，父子进程共享一份代码和数据是如何实现的呢？=> 对于代码：代码具有只读属性，也就是父子进程都不会修改，那么共享一份代码是完全可以的，同时这样还节省了内存空间 => 对于数据：事实上，子进程在创建初期，确实和父进程共享一份数据。

基于进程独立性，本身，父子进程的数据必须分离。那么在子进程创建初期，直接在内存中拷贝一份父进程的数据是完全可以的。 但是这样有很大的内存浪费的风险。=> 父进程的数据，并非所有子进程都需要使用。  即使需要使用，也不会立刻使用。  即使立刻使用，也不一定是写操作。=> 基于高效和节省内存空间的理念，我们不能采取直接拷贝一份父进程的数据。=> 故我们在子进程创建时，是和父进程共享同一份数据。=> 对于只读的，父子进程共享数据完全可以。对于父进程写的，或者子进程写的数据。基于进程独立性，必须进行数据分离。 操作系统采用的即 写时拷贝技术，来将父子进程数据分离。

进程调用fork，当控制转移到内核中的fork代码后，内核做： 

1. 分配新的内存块和内核数据结构给子进程 
2. 将父进程部分数据结构内容拷贝至子进程 
3. 添加子进程到系统进程列表当中 
4. fork返回，开始调度器调度

<img src="https://img-blog.csdnimg.cn/532a6d9f4e50444484af62a900140b39.png" alt="img" style="zoom:%;" />

### 父子进程分离数据的方式：写时拷贝

写时拷贝，在fork创建子进程这里的具体操作是：创建子进程之后，当父子进程的任何一方以写方式访问某个数据时，操作系统在内存的其他区域拷贝一份这个数据，并修改写此数据的那个进程的页表映射关系，使父子进程访问的是物理内存中的不同数据。以达到父子进程数据分离的效果，避免互相干扰。

写时拷贝好处：
在对数据进行写入时，再拷贝数据，是高效使用内存的一种表现，提高内存使用率，可以提高整机的运行效率。
写时拷贝还是一种延时申请的技术。提高内存使用率。

### 有关程序计数器和EIP寄存器：

一个事实：在fork创建子进程之后，父子进程的代码是共享的。那么为什么子进程是从fork内部的return或者说fork之后的代码开始执行呢？
我们知道，子进程的创建是以父进程为模板的，比如大部分内核数据结构，代码，数据等。包括进程地址空间，页表。都是从父进程那里拷贝过来的。=> 进程中的代码指令，每条代码指令都有地址，在CPU内部的寄存器中，有一个名为EIP的寄存器，称为程序计数器，Program Counter，简称PC。用于存放下一条需要执行的指令所在单元的地址。而CPU执行一个进程的代码指令就是依靠程序计数器。大致过程为：取指令（依据PC），分析指令（指令集架构ISA），执行指令。=> 同时，进程并非一次就将全部的指令都执行完，而是执行若干时长，就需要切换为其他进程。切换前，之前的进程需要保存好程序计数器中的数据和其他相关数据。称为进程的上下文数据。以便下次切换为此进程时，可以继续上次CPU执行指令的进度。=> 而fork创建子进程时，子进程的上下文数据都是从父进程那里拷贝过来的。所以，当子进程执行时，程序计数器中保存的指令地址致使子进程从父进程执行fork那里开始执行。同时fork之前的代码子进程是可见的，只是不是从头开始执行。

### fork常规用法

1. 一个父进程希望复制自己，使父子进程同时执行不同的代码段。例如，父进程等待客户端请求，生成子 进程来处理请求。

2. 一个进程要执行一个不同的程序。例如子进程从fork返回后，调用exec函数。（比如OJ项目中，子进程通过execl来进行g++或者运行生成的可执行程序来获取运行结果）

![image-20230808234845078](C:\Users\yangzilong\AppData\Roaming\Typora\typora-user-images\image-20230808234845078.png)

### fork什么时候会失败？

系统中有太多的进程

实际用户的进程数超过了限制

### vfork

创建一个子进程，共享同一个虚拟地址空间

## 进程终止

### 进程终止时，操作系统做了什么？

释放进程相关内核数据结构和对应的代码和数据。 即释放进程占用的资源。

### 进程终止的分类情况

1. 代码跑完，运行结果正确（符合预期）

2. 代码跑完，运行结果不正确（不符合预期）

3. 代码没有跑完，程序异常退出（崩溃）

### 进程退出码

进程退出码，是当进程执行结束后，用于标识运行结果的。
通常情况下，0标识success，非0标识结果不正确。
非零值有无数个，用不同的非零值来标识不同的错误原因。所以，依据进程退出码，可以判断上方情况的1 和 2
当进程异常退出时（崩溃），是由操作系统发送信号给进程以实现的。此时，退出码没有意义。
进程的退出码是返回给上一级进程（父进程）的，用于上一级进程获取该进程执行结果用的。（如果上一级进程不关心，则可以忽略）
C语言中定义了一套将退出码/错误码转化为字符串描述的方案，你可以设定一套自己的用于程序中。strerror库函数可以查询C语言规定的退出码对应的退出原因。
Linux下，echo $?可查询上一个进程执行的退出码

其中C/C++程序中，main函数的return值就是该进程（程序）的退出码，我们通常写的return 0即表示当main函数运行结束时，退出码为0标识结果成功。

### 用代码如何终止一个进程

1. main函数中的return语句，即标识终止此进程。（其余函数的return仅表示此函数的结束，或者返回一个值给该函数的函数调用处）

2. void exit(int status);    C语言库函数，返回status作为退出码，并终止此进程

3. void _exit(int status);    操作系统系统接口函数，返回status作为退出码，并终止此进程

main函数中执行return n等同于执行exit(n)，因为调用main的运行时函数会将main的返回值当做exit的参数。

### exit vs \_exit

一个是C语言库函数，一个是操作系统接口函数。
区别：exit在程序退出之前，会刷新C标准库设定的缓冲区。执行用户通过atexit或on_exit定义的清理函数。关闭所有打开的流，所有的缓存数据均被写入。 最后调用_exit！

## 进程等待

### 需要进行进程等待的原因

一、子进程退出之后，父进程不读取子进程的退出状态，不回收其资源。子进程变为僵尸进程。则子进程会造成内存泄漏。 
二、 除了回收子进程的资源，如果父进程想读取子进程的退出码。也需要通过进程等待的方式获取。（子进程的运行结果正确与否）

总之：父进程通过进程等待的方式，回收子进程资源，获取子进程退出信息。

### 父进程进程等待的方式

pid_t wait(int *status);     pid_ t waitpid(pid_t pid, int *status, int options);

wait只能阻塞式等待，waitpid可以选择等待方式，依据的是最后一个参数：0 or WNOHANG。

status是输出型参数，由操作系统填充，用于得到子进程的执行结果：正常 or 崩溃（看信号），正常的话，是否正确（看退出码）

status参数类型是int*，但是，并非以整型整体来获取子进程执行结果。而是按照比特位的方式。

<img src="C:\Users\yangzilong\AppData\Roaming\Typora\typora-user-images\image-20230808214330329.png" alt="image-20230808214330329" style="zoom:60%;" />

若正常终止，次低八位，表示退出码。 (status>>8) & 0xff   若崩溃，则低7位为终止信号。status & 0x7f   0x7f = 1111111
通过以上方式，即可得到status所标识的子进程退出信号 or 子进程退出码

进程PCB中是有对应的字段来保存进程的退出码和退出信号的，int exit_code, exit_signal;

多进程程序基本方式就是 fork  + wait/waitpid

## 进程程序替换

### 进程程序替换的概念+原理

用fork创建子进程后，可以用进程替换的方式，通过函数调用让子进程去执行一个全新的进程。当进程调用一种exec函数时，物理内存中保存的该进程的数据和代码将全部被替换为新的进程的代码和数据。之后，子进程会将新的进程完整执行一遍！
进程替换，并没有创建新的进程，而是完全替换了一个已存在进程的代码+数据为新进程的代码+数据。所以进程的id，优先级等不会变
并且，fork之后父子进程的代码共享，数据写时拷贝。那么，子进程进行进程替换时，数据和代码被替换，本质就是数据和代码被写入。所以此时代码也会发生写时拷贝。再将子进程的代码和数据替换为新进程的代码和数据。以此保证父子进程的独立性！！！
exec系列函数本质上，就是把新的进程的代码和数据加载到内存中！

![image-20230808235555934](C:\Users\yangzilong\AppData\Roaming\Typora\typora-user-images\image-20230808235555934.png)

### exec系列-进程替换接口函数

```c
int execl(const char *path, const char *arg, ...);
int execlp(const char *file, const char *arg, ...);
int execle(const char *path, const char *arg, ..., char * const envp[]);
int execv(const char *path, char *const argv[]);
int execvp(const char *file, char *const argv[]);
int execvpe(const char *file, char *const argv[], char *const envp[]);
int execve(const char *path, char *const argv[], char *const envp[]);
```

l(list) : 表示arg命令行参数采用列表形式    v(vector) : 表示arg命令行参数采用数组形式
p(path) : 有p自动搜索环境变量PATH    e(env) : 表示自己维护组装环境变量

第一个参数，传递要替换为的进程的路径+目标文件名，相对路径或绝对路径。 而如果函数名有p表示，第一个参数还可以传递环境变量里保存好的，比如ls，pwd。若没p，则必须传递绝对/相对路径
第二个参数，为命令行参数，在命令行上怎么执行这个进程，这里就怎么填。以列表形式 or 数组形式
第三个参数：若函数名中有e，则表示自己维护环境变量（有关这里环境变量的作用，不太理解，只能勉强用一用）exec系列函数若调用失败返回-1，若调用成功没有返回值。（也无法返回）
execve是真正的系统调用函数（man 2），上面的六个函数都是对execve的封装，适用于不同的使用场景。（man 3）
本质上，第一个参数，传路径是为了让exec找到这个程序在哪里。后面args为命令行参数，意思是怎么执行这个参数。而命令行参数，比如以NULL结尾。

<img src="C:\Users\yangzilong\AppData\Roaming\Typora\typora-user-images\image-20230808235916424.png" alt="image-20230808235916424" style="zoom: 50%;" />

一个C程序可以fork/exec另一个程序，并传给它一些参数。这个被调用的程序执行一定的操作，然后通过exit(n)来 返回值。调用它的进程可以通过wait（&ret）来获取exit的返回值。
