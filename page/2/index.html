<!DOCTYPE html>
<html lang="en">
    <head>
	<meta name="generator" content="Hugo 0.115.4">
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <title>My New Hugo Site</title><meta name="Description" content="This is my cool site"><meta property="og:title" content="My New Hugo Site" />
<meta property="og:description" content="This is my cool site" />
<meta property="og:type" content="website" />
<meta property="og:url" content="http://example.org/" /><meta property="og:image" content="http://example.org/logo.png"/><meta property="og:site_name" content="My cool site" />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="http://example.org/logo.png"/>

<meta name="twitter:title" content="My New Hugo Site"/>
<meta name="twitter:description" content="This is my cool site"/>
<meta name="application-name" content="My cool site">
<meta name="apple-mobile-web-app-title" content="My cool site"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="http://example.org/" /><link rel="alternate" href="/index.xml" type="application/rss+xml" title="My New Hugo Site">
    <link rel="feed" href="/index.xml" type="application/rss+xml" title="My New Hugo Site"><link rel="stylesheet" href="/css/style.min.css"><link rel="preload" href="/lib/fontawesome-free/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"></noscript><link rel="preload" href="/lib/animate/animate.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="/lib/animate/animate.min.css"></noscript><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "WebSite",
        "url": "http:\/\/example.org\/","inLanguage": "en","author": {
                "@type": "Person",
                "name": "xxxx"
            },"description": "This is my cool site","name": "My New Hugo Site"
    }
    </script></head>
    <body data-header-desktop="fixed" data-header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="My New Hugo Site"></a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> Posts </a><a class="menu-item" href="/tags/"> Tags </a><a class="menu-item" href="/categories/"> Categories </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="Search titles or contents..." id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="Search">
                            <i class="fas fa-search fa-fw" aria-hidden="true"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="Clear">
                            <i class="fas fa-times-circle fa-fw" aria-hidden="true"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                    <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
                </a></div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="My New Hugo Site"></a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="Search titles or contents..." id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="Search">
                            <i class="fas fa-search fa-fw" aria-hidden="true"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="Clear">
                            <i class="fas fa-times-circle fa-fw" aria-hidden="true"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        Cancel
                    </a>
                </div><a class="menu-item" href="/posts/" title="">Posts</a><a class="menu-item" href="/tags/" title="">Tags</a><a class="menu-item" href="/categories/" title="">Categories</a><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
            </a></div>
    </div>
</header><div class="search-dropdown desktop">
        <div id="search-dropdown-desktop"></div>
    </div>
    <div class="search-dropdown mobile">
        <div id="search-dropdown-mobile"></div>
    </div><main class="main">
                <div class="container"><div class="page home" data-home="posts"><div class="home-profile"><div class="home-avatar"><a href="/posts/" title="Posts"><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/images/avatar.png"
        data-srcset="/images/avatar.png, /images/avatar.png 1.5x, /images/avatar.png 2x"
        data-sizes="auto"
        alt="/images/avatar.png"
        title="/images/avatar.png" /></a></div><div class="home-subtitle"><div id="id-1" class="typeit"></div></div><div class="links"><a href="https://github.com/xxxx" title="GitHub" target="_blank" rel="noopener noreffer me"><i class="fab fa-github fa-fw" aria-hidden="true"></i></a><a href="https://twitter.com/xxxx" title="Twitter" target="_blank" rel="noopener noreffer me"><i class="fab fa-twitter fa-fw" aria-hidden="true"></i></a><a href="https://www.instagram.com/xxxx" title="Instagram" target="_blank" rel="noopener noreffer me"><i class="fab fa-instagram fa-fw" aria-hidden="true"></i></a><a href="https://facebook.com/xxxx" title="facebook" target="_blank" rel="noopener noreffer me"><i class="fab fa-facebook fa-fw" aria-hidden="true"></i></a><a href="https://t.me/xxxx" title="Telegram" target="_blank" rel="noopener noreffer me"><i class="fab fa-telegram-plane fa-fw" aria-hidden="true"></i></a><a href="mailto:xxxx@xxxx.com" title="Email" rel="me"><i class="far fa-envelope fa-fw" aria-hidden="true"></i></a><a href="/index.xml" title="RSS" target="_blank" rel="noopener noreffer me"><i class="fas fa-rss fa-fw" aria-hidden="true"></i></a></div></div>
<article class="single summary" itemscope itemtype="http://schema.org/Article"><h1 class="single-title" itemprop="name headline">
        <a href="/linux6_%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"></a>
    </h1><div class="post-meta"><span class="post-author"><a href="/" title="Author" rel="author" class="author"><i class="fas fa-user-circle fa-fw" aria-hidden="true"></i>xxxx</a></span>&nbsp;<span class="post-publish">published on <time datetime="0001-01-01">0001-01-01</time></span></div><div class="content">6_进程间通信 进程间通信的作用，应用场景，必要性 进程间通信，是建立在多进程之上的。如果是单进程，则无法利用并发能力，更加无法进行多进程协同。多进程要想实现多进程协同（目的），就必须进行进程间通信（手段）。
具体的进程间通信的目的（实例）：比如：1. 数据传输：一个进程需要将它的数据发送给另一个进程。2. 资源共享：多个进程之间共享同样的资源。 3. 通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。4. 进程控制：有些进程希望完全控制另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。
多进程通过进程间通信，比如具体的上方几个目的，实现多进程协同。（鉴于现在代码经验和知识的匮乏，可能无法切实理解到什么情况下需要多进程协同，但是这样的需求和场景肯定是存在的，需要后面不断的学习）
进程间通信的技术背景 进程是具有独立性的，这是在学习进程时，进程的一大特点。
进程 = 进程的内核数据结构 + 进程对应的代码和数据。不管是两个独立的进程，还是父进程fork创建子进程，进程的内核数据结构还有代码和数据都是有独立性的。因为虚拟地址空间+页表的存在，进程的虚拟地址通过页表映射到物理内存的不同区域，即使是父进程fork创建子进程，子进程的内核数据结构也会有独立的一份，而代码和数据在创建之初和父进程共享，但是因为写时拷贝技术的存在，子进程的代码和数据仍然是具有独立性的（比如，非常量全局数据，在父子进程之一写时，会拷贝一份。而代码，比如调用execl函数进行进程切换时，也会发生代码的写时拷贝）
因此，基于进程独立性，进程间如果想进行通信，成本是比较高的。
进程间通信的本质理解 因为进程是具有独立性的
所以，要想实现进程间通信，首先要让不同进程看到同一份资源（同一块&quot;内存&quot;，这个内存是特定的结构组织的），这个内存资源，不能隶属于任何一个进程，而更应该强调共享（其实就是属于操作系统管理的）
管道IPC：匿名管道 匿名管道的本质原理 在父进程fork创建子进程时，子进程会有自己独立的内核数据结构（如页表，虚拟地址空间，PCB，文件描述符表等），而这其中的文件描述符表中每一个元素存储的是该进程打开的所有文件对应的内核struct file结构体的地址。
当父进程fork创建子进程，子进程的大部分内核数据结构的数据都是从父进程那里直接拷贝过来的（包括虚拟地址空间，页表等），当然，部分字段还是需要修改的（如pid等），而其中的文件描述符表的数据是与父进程完全一致的。
因此，当父进程以读和写方式打开某一个文件之后，进行fork，子进程继承了父进程的文件描述符表，子进程也以读和写方式打开了这个文件。因为管道是单向通信的，故父子进程关闭自己不需要的一端之后，就可以通过该匿名管道文件进行通信。
demo示例代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 #include &lt;unistd.</div><div class="post-footer">
        <a href="/linux6_%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/">Read More</a></div>
</article><article class="single summary" itemscope itemtype="http://schema.org/Article"><h1 class="single-title" itemprop="name headline">
        <a href="/linux7_%E8%BF%9B%E7%A8%8B%E4%BF%A1%E5%8F%B7/"></a>
    </h1><div class="post-meta"><span class="post-author"><a href="/" title="Author" rel="author" class="author"><i class="fas fa-user-circle fa-fw" aria-hidden="true"></i>xxxx</a></span>&nbsp;<span class="post-publish">published on <time datetime="0001-01-01">0001-01-01</time></span></div><div class="content">7_进程信号 信号的基本认识 Linux信号机制：
它是一种异步的通知机制，用来提醒进程一个事件已经发生。
Linux操作系统中，有编号为1~31的31个普通信号，编号为34~64的31个实时信号，共62个信号。日常中只会涉及和使用到普通信号。故下方对信号的学习仅对于1~31的普通信号。
每个信号都有一个编号和一个宏定义名称，本质上，这些都是通过#define的形式定义的。也就是用一个int型变量去代替某特定信号。（编译之后，这些宏定义都会变为int整型）
进程处理信号的三种方式 信号的接收方一定是进程，因为信号就是OS用来提醒进程某个事件已经发生。故，进程在接收到信号之后，一定要处理这个信号。
执行该信号的默认处理动作。
忽略该信号。
提供一个信号处理函数，要求内核在处理该信号时切换到用户态执行这个处理函数，这种方式称为捕捉（Catch）一个信号。 （其实就是程序员自定义进程对某信号的处理方法，该方法存储在用户代码中）
简单来说就是默认，忽略，自定义捕捉。
信号产生：产生信号的若干种方式 1.通过键盘产生信号： ctrl + c：通过键盘组合键向前台进程发送2号SIGINT信号。
ctrl + \：通过键盘组合键向前台进程发送3号SIGQUIT信号。
理解：键盘是通过中断的方式工作的。输入某组合键-&gt;OS解释识别组合键-&gt;查找进程列表-&gt;前台运行的进程-&gt;OS将前台运行进程的PCB(task_struct)中的pending信号集位图中组合键对应的信号所对应的比特位由0置1（pending 信号集本质是一个位图结构，见信号保存。）（其实最后一步一句话就是：OS向前台进程发送对应信号，发送信号的本质就是如此）
有关前台进程与后台进程： Ctrl-C 产生的信号只能发给前台进程。一个命令后面加个&amp;可以放到后台运行（如 ./mysignal &amp;）,这样Shell不必等待进程 结束就可以接受新的命令,启动新的进程。Shell可以同时运行一个前台进程和任意多个后台进程,只有前台进程才能接到像 Ctrl-C 这种控制键产生的信号
前台进程在运行过程中用户随时可能按下 Ctrl-C 而产生一个信号,也就是说该进程的用户空间代码执行 到任何地方都有可能收到 SIGINT 信号而终止,所以信号相对于进程的控制流程来说是**异步(Asynchronous)**的。
2.通过系统调用接口产生信号： int kill(pid_t pid, int signo); 向指定进程发送指定信号
int raise(int signo); 向当前进程发送指定信号
void abort(void); 向当前进程发送6号SIGABRT信号
Linux还有一个kill命令，就是通过调用kill函数实现的。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 通过系统调用发送信号 void handler(int signo) { std::cout &lt;&lt; &#34;进程收到了一个&#34; &lt;&lt; signo &lt;&lt; &#34;号信号&#34; &lt;&lt; std::endl; } int main() { signal(2, handler); // 捕捉下方kill 和 raise发送的信号 signal(SIGABRT, handler); // 捕捉abort发送的6号SIGABRT信号 kill(getpid(), 2); raise(2); abort(); // 向当前进程发送SIGABRT信号，使其异常终止（默认） while(true) sleep(1); return 0; } 如上图，对6号SIGABRT信号明明捕捉了但是还是中止了。 这是一个很奇怪的现象，查了stack overflow：However, I cannot find any corroborating evidence of that behavior in the signal man page, which clearly states that The signals SIGKILL and SIGSTOP cannot be caught, blocked, or ignored but makes no similar mention for SIGABRT.</div><div class="post-footer">
        <a href="/linux7_%E8%BF%9B%E7%A8%8B%E4%BF%A1%E5%8F%B7/">Read More</a></div>
</article><article class="single summary" itemscope itemtype="http://schema.org/Article"><h1 class="single-title" itemprop="name headline">
        <a href="/linux8.0_linux%E5%A4%9A%E7%BA%BF%E7%A8%8B/"></a>
    </h1><div class="post-meta"><span class="post-author"><a href="/" title="Author" rel="author" class="author"><i class="fas fa-user-circle fa-fw" aria-hidden="true"></i>xxxx</a></span>&nbsp;<span class="post-publish">published on <time datetime="0001-01-01">0001-01-01</time></span></div><div class="content">线程概念 线程在进程内部执行，是OS调度的基本单位。 线程是进程的一个执行分支，是在进程内部运行的一个执行流。 在一个程序里的一个执行路线就叫做线程（thread）。更准确的定义是：线程是“一个进程内部的控制序列”。 线程（英语：thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。 历史上，早期，操作系统中是没有线程的，也就是只有进程这个概念，一个进程内只有一个执行流。60年代，在OS中能拥有资源和独立运行的基本单位是进程，然而随着计算机技术的发展，进程出现了很多弊端，一是由于进程是资源拥有者，创建、撤消与切换存在较大的时空开销，因此需要引入轻型进程；二是由于对称多处理机（SMP）出现，可以满足多个运行单位，而多个进程并行开销过大。
因此在80年代，出现了能独立运行的基本单位——线程（Threads）。
线程有着自己的特点，比如执行粒度更细，更轻量化，调度切换的开销更小等等，而不同操作系统设计线程时有着不同的方案，Windows对于线程，设立了全新的数据结构，进程和线程划分的很清晰，这是比较复杂的。而因为线程创建，执行，切换，销毁等等很多行为都和进程有着很大的相似性，因此Linux采用了用进程模拟线程的设计方案（实现了进程内核代码的复用），这样的设计方案虽然没有为线程设计全新的数据结构，但是最终设计出的“轻量级进程”依旧符合线程的要求。
上图为学习线程之前，进程加载运行的示意图，每个进程都有一个task_struct（Linux），即进程PCB。
Linux线程的原理 Linux线程原理：OS内，如果我们创建“进程”时，不创建新的地址空间，用户级页表，不进行IO将程序的代码和数据加载到内存 只创建task_struct，让这个新的PCB指向旧的PCB（创建此新线程的主线程)指向的地址空间mm_struct，再通过一定的技术手段，将当前进程的资源合理划分给不同的task_struct，此时，这里的每一个task_struct，就称为一个线程。
线程在进程内部执行，指的是线程在进程的地址空间内运行。 每个进程内至少有一个执行线程（一个执行流） 在Linux系统中，在CPU眼中，看到的PCB都要比传统的进程的PCB更加轻量化，因此将Linux下的进程统一称之为轻量级进程。（多执行流时，PCB task_struct占用整个进程的一部分资源，当然轻量化） 之前一个进程，代码执行流程一定是按顺序执行的，多线程之后，就可以进行资源划分，所有线程共享一个地址空间，一个页表。此时的执行就由串型执行变为并发执行，效率更高。(??? 我们之前所写的程序为内部只有一个执行流的进程。而多线程即内部具有多个执行流的进程。 重新理解定义task_struct：进程内部的一个执行流（Linux下） CPU执行的基本单位是线程，OS调度的基本单位是线程。但并不是OS只能调度线程，实际上OS也是可以以进程整体为单位进行调度的。（见下方疑问） 重新理解进程的概念 如上红色区域即进程全部。
从用户视角来说：进程=内核数据结构+进程对应的代码和数据（内核数据结构中PCB的数量&gt;= 1）
从内核视角来说：进程：承担分配系统资源的基本实体。（因为在进程创建时，系统给这个进程分配资源。而线程是使用创建此线程的进程的部分资源，进程进行资源分配，分配给线程。故进程才是承担分配系统资源的基本实体）
疑问
对于线程这块我有个疑惑，既然CPU和OS调度的基本单位是线程，且一个进程内至少有一个执行线程（一个执行流），那能不能说CPU和OS只能调度线程呢，也就是理解为CPU调度一个单执行流进程时，本质上也是调度此进程内的一个执行线程？
一个CSDN链接，可供参考
调度是一方面，另一方面是调度的目的是什么。如果调度的目的是为了让执行流去执行，那肯定是让线程去跑。而如果目的是以进程整体为单位进行资源分配，则OS也是可以做到调度整个进程的。对于CPU来说，特别是Linux下，CPU并不关心线程还是进程，它只关心task_struct，因为在Linux下，只存在轻量级进程，不存在线程。只是用轻量级进程去模拟线程。
线程优缺点 线程的优点 创建一个新线程的代价要比创建一个新进程小得多（创建时的成本更小
与进程之间的切换相比，线程之间的切换需要操作系统做的工作要少很多（切换的成本更小
线程占用的资源要比进程少很多（占用的资源更少
能充分利用多处理器的可并行数量（并行
在等待慢速I/O操作结束的同时，程序可执行其他的计算任务
计算密集型应用，为了能在多处理器系统上运行，将计算分解到多个线程中实现
I/O密集型应用，为了提高性能，将I/O操作重叠。线程可以同时等待不同的I/O操作。
线程的缺点 性能损失 一个很少被外部事件阻塞的计算密集型线程往往无法与其它线程共享同一个处理器。如果计算密集型线程的数量比可用的处理器多，那么可能会有较大的性能损失，这里的性能损失指的是增加了额外的同步和调度开销，而可用的资源不变。
健壮性降低 编写多线程需要更全面更深入的考虑，在一个多线程程序里，因时间分配上的细微偏差或者因共享了不该共享的变量而造成不良影响的可能性是很大的，换句话说线程之间是缺乏保护的。
缺乏访问控制 进程是访问控制的基本粒度，在一个线程中调用某些OS函数会对整个进程造成影响。
编程难度提高 编写与调试一个多线程程序比单线程程序困难得多
线程异常 单个线程如果出现除零，野指针问题导致线程崩溃，进程也会随着崩溃
线程是进程的执行分支，线程出异常，就类似进程出异常，进而触发信号机制，终止进程，进程终止，该进程内的所有线程也就随即退出
线程用途 合理的使用多线程，能提高CPU密集型程序的执行效率
合理的使用多线程，能提高IO密集型程序的用户体验（如生活中我们一边写代码一边下载开发工具，就是 多线程运行的一种表现）
进程vs线程 进程是资源分配的基本单位
线程是调度的基本单位。
线程共享进程内的部分数据 **进程内的所有线程共享同一个进程地址空间，则其中的代码区，全局数据区，共享区，命令行参数和环境变量，内核区都是共享的。**而对于堆区和栈区，根本上来说是共享的，因为一个线程可以将栈帧内的局部数据或堆区开辟空间的地址通过全局数据的方式传递给其他线程，其他线程也可以访问。但是一般情况下我们不会这样做，所以也可以认为栈区和堆区是线程私有的。
除此之外，各线程还共享进程内的文件描述符表（一个线程打开一个文件，其他线程也会自动打开），各种信号的处理方式（SIG_IGN，SIG_DFL或者自定义的信号处理函数（代码区）），当前工作目录，用户id和组id等&hellip;
属于线程自己的一部分数据 线程id，errno，信号屏蔽字，调度优先级。
最重要的是：每个线程私有 一组寄存器和栈。
一组寄存器：线程是CPU调度的基本单位，每个线程一定有自己的上下文。在线程被CPU调度时，上下文数据就会保存在CPU内的一组寄存器中。
栈：每个线程运行时要调用函数，一定有出栈入栈的行为，形成的临时变量会保存在栈内，故每个线程必须有自己的私有栈。
一组寄存器和栈能体现出线程的动态属性。
验证每个线程有独立的信号屏蔽字
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;thread&gt; #include &lt;signal.</div><div class="post-footer">
        <a href="/linux8.0_linux%E5%A4%9A%E7%BA%BF%E7%A8%8B/">Read More</a></div>
</article><article class="single summary" itemscope itemtype="http://schema.org/Article"><h1 class="single-title" itemprop="name headline">
        <a href="/linux8.1_%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/"></a>
    </h1><div class="post-meta"><span class="post-author"><a href="/" title="Author" rel="author" class="author"><i class="fas fa-user-circle fa-fw" aria-hidden="true"></i>xxxx</a></span>&nbsp;<span class="post-publish">published on <time datetime="0001-01-01">0001-01-01</time></span></div><div class="content">线程互斥 线程互斥及相关概念 **线程互斥（Mutual Exclusion）**是指在多线程环境下，同一时刻只能有一个线程访问共享资源，以避免对该资源的不正确访问，造成数据不一致等问题。 例如，如果有多个线程都要同时对同一个全局变量进行修改，那么就需要使用线程互斥来保证对该变量的访问是互斥的，也就是说，在任意时刻只能有一个线程对该变量进行访问。
**临界资源（Critical Resource）**是指在多线程环境下需要被多个线程共享访问的资源，对该资源的访问需要进行同步（如使用互斥进行同步）以避免出现不正确的访问。
临界区：每个线程内部，访问临界资源的代码，就叫做临界区
互斥：任何时刻，互斥保证有且只有一个执行流进入临界区，访问临界资源，通常对临界资源起保护作用。是对临界资源保护的一种手段。
原子性：不会被任何调度机制影响的操作，该操作只有两态，要么完成，要么未完成。
互斥量mutex： 大部分情况，线程使用的数据都是局部变量，变量的地址空间在线程栈空间内，这种情况，变量归属单个线程，其他线程无法获得这种变量。 但有时候，很多变量都需要在线程间共享，这样的变量称为共享变量，可以通过数据的共享，完成线程之间的交互。 多个线程并发的操作共享变量，会带来一些问题。
多线程抢票 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include &lt;iostream&gt; #include &lt;pthread.h&gt; #include &lt;string&gt; #include &lt;unistd.</div><div class="post-footer">
        <a href="/linux8.1_%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/">Read More</a></div>
</article><article class="single summary" itemscope itemtype="http://schema.org/Article"><h1 class="single-title" itemprop="name headline">
        <a href="/linux8.2_%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/"></a>
    </h1><div class="post-meta"><span class="post-author"><a href="/" title="Author" rel="author" class="author"><i class="fas fa-user-circle fa-fw" aria-hidden="true"></i>xxxx</a></span>&nbsp;<span class="post-publish">published on <time datetime="0001-01-01">0001-01-01</time></span></div><div class="content">生产者消费者模型是什么 生产者消费者模型中有三个关键成员：生产者、消费者和缓冲区。
生产者（Producer）：生产者负责生产数据，并将数据存储到缓冲区中。在多线程场景中，生产者线程是用来执行生产者任务的线程。
消费者（Consumer）：消费者负责从缓冲区中取出数据，并消费数据。在多线程场景中，消费者线程是用来执行消费者任务的线程。
缓冲区（Buffer）：缓冲区是用来存储生产者生产的数据的地方，同时也是消费者从中取出数据的地方。缓冲区可以是一个数组、队列、链表等数据结构。在多线程场景中，缓冲区需要通过互斥和条件变量等同步机制来实现生产者和消费者之间的协调和同步。
生产者、消费者和缓冲区是生产者消费者模型中的三个关键成员，它们之间的协调和同步可以通过同步机制来实现。这种模型可以有效地实现资源的共享和利用，提高系统的效率。
便于记忆：321原则
一个交易场所：缓冲区
二个角色：生产者，消费者
三种关系：生产者和生产者：竞争，互斥关系。消费者和消费者：竞争，互斥关系。生产者和消费者：互斥，同步关系。（利用互斥锁和条件变量来实现。）
基于阻塞队列BlockingQueue的生产者消费者模型 在多线程编程中阻塞队列(Blocking Queue)是一种常用于实现生产者消费者模型的数据结构。生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，
其与普通的队列区别在于，当队列为空时，从队列获取元素的操作（消费者线程进行）将会被阻塞，直到队列中被放入了元素（生产者线程进行）；当队列满时，往队列里存放元素的操作（生产者线程进行）会被阻塞，直到有元素被从队列中取出（消费者线程进行）(以上的操作都是基于不同的线程来说的，线程在对阻塞队列进行操作时会被阻塞)
因为缓冲区实际上就是一个某种数据结构组织的内存空间，只是这里用队列来充当这个缓冲区，同时加了同步和互斥机制，所以是一个阻塞队列。
阻塞队列生产消费模型代码实现 zzz
互斥锁&amp;共享变量 因为利用条件变量进行了线程同步，因此可以让线程能够按照某种特定的顺序访问临界资源，从而有效避免饥饿问题。（生产者和消费者调用pthread_cond_siganl时是按照条件变量的等待顺序进行唤醒的）
条件变量的使用需要环境，在生产者消费者模型中，生产者生产完数据之后，可以signal消费者，因为生产者知道缓冲区中新增数据了。消费者消费完数据之后，可以signal生产者，因为消费者知道缓冲区中有空间了。
为什么int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex)的第二个参数是一个互斥锁：当一个线程调用此函数时，是因为它检测到了临界资源不就绪，不满足访问条件，因此它需要等待（例如消费者等待生产者生产数据），而对于临界资源的检测本身也是一种访问，故需要在互斥的条件下进行，也就是加锁和解锁之间。因此，当线程调用pthread_cond_wait时，需要传入一个互斥锁，pthread_cond_wait会先将互斥锁解锁，以便其它线程可以进入临界区访问临界资源。比如：消费者检测阻塞队列内没有数据，需要等待，但是它必须先把互斥锁进行解锁，生产者才能进入临界区生产数据。
pthread_cond_wait第二个参数是一个锁，当成功调用wait之后，传入的锁，会被自动释放！当线程被唤醒的时候，pthread_cond_wait，会自动帮助线程获取锁（要竞争锁）。由此可见，条件变量本身就是和互斥锁配合起来使用的。
pthread_cond_wait是一个函数，可能调用失败，也可能存在伪唤醒的情况，因此编码规范为：while (临界资源不就绪） pthread_cond_wait(cond, mutex);
为什么 pthread_cond_wait 需要互斥量（上方的第三点） 条件等待是线程间同步的一种手段，如果只有一个线程，条件不满足，一直等下去都不会满足，所以必须要有一个线程通过某些操作，改变共享变量，使原先不满足的条件变得满足，并且友好的通知等待在条件 变量上的线程。
条件不会无缘无故的突然变得满足了，必然会牵扯到共享数据的变化。所以一定要用互斥锁来保护。没有互斥锁就无法安全的获取和修改共享数据。
按照上面的说法，我们设计出如下的代码：先上锁，发现条件不满足，解锁，然后等待在条件变量上不就行了~（等待临界资源条件就绪，这个状态变化一定是由其他线程来完成的）
生产者消费者模型的优点 分离生产和消费，提高系统的解耦性和可维护性。
充分利用多核CPU的并行处理能力，从而提高系统的处理性能和响应速度。
注意：生产消费的过程并非只是生产者往缓冲区放数据，消费者从缓冲区拿数据。更重要和耗时的是生产者生产数据和消费者处理数据的过程。因为缓冲区放数据和拿数据是互斥的，所以这里的执行是串行执行的，并没有提高效率。真正提高效率的是，提高生产者生产数据和消费者处理数据的并发度。以避免出现生产过剩或消费不及的情况，从而使系统的负载保持在一个合理的范围内。
设计多生产者多消费者的目的也是为了提高生产数据和消费数据的并发度，当然，如果生产数据和消费数据的过程很简单，则多生产多消费的意义也就不大了。若过程是大量IO的过程，则可以提高整体效率。(IO密集型)
生产者消费者模式就是通过一个容器来解决生产者和消费者的强耦合问题。
**阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。**支持忙闲不均。
前面的生产消费代码，可以把生产者输入整数和消费者消费整数稍微修改一下，体现出生产者生产数据和消费者处理数据的过程&hellip; 略略略
信号量（POSIX信号量） 信号量的理解 在Linux下，POSIX信号量是一种线程同步机制，用于控制多个线程之间的访问顺序。POSIX信号量可以用于实现线程之间的互斥与同步。
在之前的阻塞队列生产者消费者模型中，阻塞队列是一个共享资源，不管是生产者还是消费者，任何时刻只允许一个线程访问共享资源，所以对阻塞队列进行了加锁保护，使阻塞队列成为为临界资源。在这里，是将整个共享资源（阻塞队列）当作一个整体使用的。
信号量使用思路与场景：一个共享资源，不当作整体使用，将其划分为若干个小的共享资源，使得不同的执行流访问不同的小共享资源，本质上，当不同执行流访问不同的小共享资源时，不需要进行加锁保护，可以并发执行。而如果两个执行流访问到了同一个小的共享资源时，再进行互斥保护共享资源。
POSIX信号量提供了两种类型的信号量
二进制信号量：只有两个取值：0和1，它用于表示资源是否被占用。 二进制信号量可以充当互斥锁的作用。因为信号量的初始值为1，p相当于加锁，v相当于解锁。
计数信号量：可以有多个取值，它表示可用资源的数量。 计数信号量的值通常被称为“资源计数器”，它记录了当前可用的共享资源数量。当一个线程需要使用共享资源时，它会尝试获取计数信号量，如果当前可用资源数量大于0，则线程可以获取资源并将计数信号量的值减1。如果当前可用资源数量为0，则表示共享资源已被占用，线程需要等待直到有资源可用。
POSIX信号量接口 1 2 3 4 int sem_init(sem_t *sem, int pshared, unsigned int value); // 初始化 int sem_destroy(sem_t *sem); // 销毁 int sem_wait(sem_t *sem); // 申请信号量，P操作 int sem_post(sem_t *sem); // 释放信号量，V操作 因为信号量本质就是一个计数器，记录着当前的资源数目，其中初始化时的value值就表示初始时的资源数目。</div><div class="post-footer">
        <a href="/linux8.2_%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/">Read More</a></div>
</article><article class="single summary" itemscope itemtype="http://schema.org/Article"><h1 class="single-title" itemprop="name headline">
        <a href="/linux8.3_%E7%BA%BF%E7%A8%8B%E6%B1%A0/"></a>
    </h1><div class="post-meta"><span class="post-author"><a href="/" title="Author" rel="author" class="author"><i class="fas fa-user-circle fa-fw" aria-hidden="true"></i>xxxx</a></span>&nbsp;<span class="post-publish">published on <time datetime="0001-01-01">0001-01-01</time></span></div><div class="content">线程池: 一种线程使用模式。线程过多会带来调度开销，进而影响缓存局部性和整体性能。而线程池维护着多个线程，等待着监督管理者分配可并发执行的任务。**这避免了在处理短时间任务时创建与销毁线程的代价。****线程池不仅能够保证内核的充分利用，还能防止过分调度。**可用线程数量应该取决于可用的并发处理器、处理器内核、内存、网络sockets等的数量。
线程池的应用场景: 需要大量的线程来完成任务，且完成任务的时间比较短。 WEB服务器完成网页请求这样的任务，使用线程池技术是非常合适的。因为单个任务小，而任务数量巨大，你可以想象一个热门网站的点击次数。 但对于长时间的任务，比如一个Telnet连接请求，线程池的优点就不明显了。因为Telnet会话时间比线程的创建时间大多了。 对性能要求苛刻的应用 比如要求服务器迅速响应客户请求。 接受突发性的大量请求，但不至于使服务器因此产生大量线程的应用。 突发性大量客户请求，在没有线程池情况下，将产生大量线程，虽然理论上大部分操作系统线程数目最大值不是问题。但短时间内产生大量线程可能使内存到达极限， 出现错误 线程池的种类: 线程池示例: 创建固定数量线程的线程池，循环从任务队列中获取任务对象。 获取到任务对象后，执行任务对象中的任务接口 C++实现简单的线程池 tiny线程池
log.hpp就是一个打印日志的功能。mutex.hpp实现了一个RAII式的加锁解锁类，参数是一个锁指针。
task.hpp就是对线程池内线程执行的任务的一个简单模拟。main函数生产task，调用线程池的pushTask方法，将task放入线程池的任务队列中，线程池内等待任务的线程被signal然后执行任务。
thread.hpp对于线程的封装，线程的数据成员有线程名，执行例程方法，参数，tid。就是一个很简单的封装。并不是构造时直接pthread_create，而是需要调用一个create方法。线程池构造时构造若干个thread对象。线程池的run方法中调用线程的create方法，使线程执行routine等待任务队列中的任务。
线程池的基本原理就是生产消费模型，main函数充当生产者，放入线程池的任务队列缓冲区中，然后利用条件变量唤醒pthread_cond_wait的线程，线程执行任务。这里需要加锁保护临界资源，在生产消费之间，消费消费之间都需要加锁实现互斥(因为此处仅main在生产，故没有生产生产之间的关系，但是也实现了互斥)，还需要条件变量实现同步机制。
对于routine函数，因为类的普通成员方法有一个隐藏的this指针参数，因此不能直接作为线程的执行例程方法（void*(*p)(void*)），因此需要将其定为static，但是static方法不能访问非static数据成员。也就导致了不能直接访问task_queue_，mutex，cond等数据成员，如果想直接访问，需要加static。但是如果这样的话，所有线程池都共用一个任务列表，锁，条件变量是不合适的。
解决方法是：将routine设为static方法，然后线程传参时传一个线程池对象的this指针过去，static成员方法不能访问非static数据成员的原因就是因为没有this指针。现在传一个过去，这个routine就可以访问任何非static数据成员和非static方法了。
有关加锁，和条件变量的使用，就是常规的生产消费模型中锁和条件变量的使用。
单例模式 单例模式是什么 单例模式是一种 &ldquo;经典的, 常用的, 常考的&rdquo; 设计模式.
单例模式的特点 某些类, 只应该具有一个对象(实例), 就称之为单例.例如一个男人只能有一个媳妇.
在很多服务器开发场景中, 经常需要让服务器加载很多的数据 (上百G) 到内存中. 此时往往要用一个单例的类来管理这些数据.
饿汉模式与懒汉模式 分为懒汉模式和饿汉模式。懒汉方式最核心的思想是 &ldquo;延时加载&rdquo;. 从而能够优化服务器的启动速度.
饿汉方式实现单例模式 1 2 3 4 5 6 7 8 9 template &lt;typename T&gt; class Singleton { private: static T data; public: static T* GetInstance() { return &amp;data; } }; 只要通过 Singleton 这个包装类来使用 T 对象, 则一个进程中只有一个T对象的实例。</div><div class="post-footer">
        <a href="/linux8.3_%E7%BA%BF%E7%A8%8B%E6%B1%A0/">Read More</a></div>
</article><ul class="pagination"><li class="page-item ">
                    <span class="page-link">
                        <a href="/">1</a>
                    </span>
                </li><li class="page-item active">
                    <span class="page-link">
                        <a href="/page/2/">2</a>
                    </span>
                </li><li class="page-item ">
                    <span class="page-link">
                        <a href="/page/3/">3</a>
                    </span>
                </li></ul></div></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">Powered by <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.115.4">Hugo</a> | Theme - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.11"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden="true"></i> LoveIt</a>
                </div><div class="footer-line" itemscope itemtype="http://schema.org/CreativeWork"><i class="far fa-copyright fa-fw" aria-hidden="true"></i><span itemprop="copyrightYear">2019 - 2023</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/" target="_blank">xxxx</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="Back to Top">
                <i class="fas fa-arrow-up fa-fw" aria-hidden="true"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="View Comments">
                <i class="fas fa-comment fa-fw" aria-hidden="true"></i>
            </a>
        </div><link rel="stylesheet" href="/lib/katex/katex.min.css"><link rel="stylesheet" href="/lib/cookieconsent/cookieconsent.min.css"><script type="text/javascript" src="/lib/autocomplete/autocomplete.min.js"></script><script type="text/javascript" src="/lib/lunr/lunr.min.js"></script><script type="text/javascript" src="/lib/lazysizes/lazysizes.min.js"></script><script type="text/javascript" src="/lib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="/lib/sharer/sharer.min.js"></script><script type="text/javascript" src="/lib/typeit/index.umd.js"></script><script type="text/javascript" src="/lib/katex/katex.min.js"></script><script type="text/javascript" src="/lib/katex/contrib/auto-render.min.js"></script><script type="text/javascript" src="/lib/katex/contrib/copy-tex.min.js"></script><script type="text/javascript" src="/lib/katex/contrib/mhchem.min.js"></script><script type="text/javascript" src="/lib/cookieconsent/cookieconsent.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"Copy to clipboard","maxShownLines":50},"cookieconsent":{"content":{"dismiss":"Got it!","link":"Learn more","message":"This website uses Cookies to improve your experience."},"enable":true,"palette":{"button":{"background":"#f0f0f0"},"popup":{"background":"#1aa3ff"}},"theme":"edgeless"},"data":{"id-1":"This is My New Hugo Site"},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":true,"left":"\\begin{equation}","right":"\\end{equation}"},{"display":true,"left":"\\begin{equation*}","right":"\\end{equation*}"},{"display":true,"left":"\\begin{align}","right":"\\end{align}"},{"display":true,"left":"\\begin{align*}","right":"\\end{align*}"},{"display":true,"left":"\\begin{alignat}","right":"\\end{alignat}"},{"display":true,"left":"\\begin{alignat*}","right":"\\end{alignat*}"},{"display":true,"left":"\\begin{gather}","right":"\\end{gather}"},{"display":true,"left":"\\begin{CD}","right":"\\end{CD}"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"search":{"highlightTag":"em","lunrIndexURL":"/index.json","maxResultLength":10,"noResultsFound":"No results found","snippetLength":30,"type":"lunr"},"typeit":{"cursorChar":"|","cursorSpeed":1000,"data":{"id-1":["id-1"]},"duration":-1,"speed":100}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
