<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>All Posts - My New Hugo Site</title>
        <link>http://example.org/posts/</link>
        <description>All Posts | My New Hugo Site</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><atom:link href="http://example.org/posts/" rel="self" type="application/rss+xml" /><item>
    <title></title>
    <link>http://example.org/linux1_%E5%B8%B8%E8%A7%81%E6%8C%87%E4%BB%A4%E4%BB%A5%E5%8F%8A%E6%9D%83%E9%99%90%E7%90%86%E8%A7%A3/</link>
    <pubDate>Mon, 01 Jan 0001 00:00:00 &#43;0000</pubDate>
    <author>xxxx</author>
    <guid>http://example.org/linux1_%E5%B8%B8%E8%A7%81%E6%8C%87%E4%BB%A4%E4%BB%A5%E5%8F%8A%E6%9D%83%E9%99%90%E7%90%86%E8%A7%A3/</guid>
    <description><![CDATA[1_常见指令以及权限理解 Linux 基础指令 ls pwd cd 改变工作目录 touch touch命令参数可更改文档或目录的日期时间，包括存取时间和更改时间，或者新建一个不存在的文件。 mkdir [-p] rm man 1 是普通的命令 2 是系统调用,如open,write之类的 3 是库函数,如printf,fread cp cp [选项] 源文件或目录 目标文件或目录 mv 移动文件/目录 重命名文件/目录 cat 查看目标文件的内容 less 功能更强大的浏览文件内容的工具 head tail find find pathname -options -name 按照文件名查找文件 grep [选项] 搜寻字符串 文件 -i ：忽略大小写的不同，所以大小写视为相同 -n ：顺便输出行号 -v ：反向选择，亦即显示出没有 &lsquo;搜寻字符串&rsquo; 内容的那一行 zip [选项] 压缩文件.zip 目录或文件 -r 递归处理，将指定目录下的所有文件和子目录一并处理 tar 打包/解包 = = 暂时略了 Linux 扩展指令 top ps su su [用户名] 切换用户 su root 时root可省略（Linux下的两种用户：超级用户root和普通用户） who chmod chown chgrp netstat ipconfig Shell命令及其运行原理（Bash） Linux权限 ]]></description>
</item>
<item>
    <title></title>
    <link>http://example.org/linux2_linux%E7%8E%AF%E5%A2%83%E5%9F%BA%E7%A1%80%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/</link>
    <pubDate>Mon, 01 Jan 0001 00:00:00 &#43;0000</pubDate>
    <author>xxxx</author>
    <guid>http://example.org/linux2_linux%E7%8E%AF%E5%A2%83%E5%9F%BA%E7%A1%80%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/</guid>
    <description><![CDATA[2_Linux环境基础开发工具使用 Linux 软件包管理器 yum Linux开发工具 Linux编辑器-vim使用 Linux编译器-gcc/g++使用 预处理 编译 汇编 连接 函数库：静态库/动态库
Linux调试器-gdb使用 Linux项目自动化构建工具-make/Makefile Linux第一个小程序－进度条
使用 git 命令行 ]]></description>
</item>
<item>
    <title></title>
    <link>http://example.org/linux3_linux%E8%BF%9B%E7%A8%8B%E6%A6%82%E5%BF%B5/</link>
    <pubDate>Mon, 01 Jan 0001 00:00:00 &#43;0000</pubDate>
    <author>xxxx</author>
    <guid>http://example.org/linux3_linux%E8%BF%9B%E7%A8%8B%E6%A6%82%E5%BF%B5/</guid>
    <description><![CDATA[3_Linux进程概念 冯诺依曼体系结构 操作系统(Operator System) 进程 进程的基本概念 进程是正在运行的程序的实例（an instance of a computer program that is being executed）
在操作系统中运行的程序。程序的一个执行实例。
内核观点：承担分配系统资源（CPU时间，内存）的实体。
描述进程 - PCB PCB ：Process Control Block 进程控制块
作用 : 用于描述操作系统中的进程的数据结构
为了描述控制进程的运行，系统中存放进程的管理和控制信息的数据结构称为进程控制块（PCB Process Control Block），它是进程实体的一部分，是操作系统中最重要的记录性数据结构。它是进程管理和控制的最重要的数据结构，每一个进程均有一个PCB，在创建进程时，建立PCB，伴随进程运行的全过程，直到进程撤消而撤消。- from百度百科
为什么要有PCB？PCB的作用？ 六个字：先描述，再组织。 这是一个管理的观念，比如我们写C++程序时，写的类就是为了描述某一个事物，而创建了类的实例化&gt;对象之后，用某一个数据结构将其组织起来，就叫做再组织。之后再使用某些算法就可以达到管理对象。 这个观念在程序开发和很&gt;多场景下都适用，而C++中的STL就是为了帮助我们更方便地组织实例化对象。 所以，在操作系统中，进程也是一个事物，操作系统要管理进程，那么最好的方法就是先描述，再组织。而描述，采用的方法就是利用一个strcut（Linux是用C写的，使用的是struct，其他操作系统未知）去存储进程的各种属性来描述进程。之后再在内存中，用数据结构将这些PCB（结构体）组织起来，来达到更好地管理进程的目的。
task_struct - Linux下的PCB 在Linux操作系统中，描述进程的结构体叫做task_struct，Linux的PCB名为task_struct。它们的关系就像是：警察是一种职业，task_struct是一种PCB。
task_struct是Linux内核的一种数据结构，它会被装载到RAM(内存)里并且包含着进程的信息。
task_ struct内容分类 标示符: 描述本进程的唯一标示符，用来区别其他进程。 状态: 任务状态，退出代码，退出信号等。 优先级: 相对于其他进程的优先级。 程序计数器: 程序中即将被执行的下一条指令的地址。 内存指针: 包括程序代码和进程相关数据的指针，还有和其他进程共享的内存块的指针 上下文数据: 进程执行时处理器的寄存器中的数据[休学例子，要加图CPU，寄存器]。 I／O状态信息: 包括显示的I/O请求,分配给进程的I／O设备和被进程使用的文件列表。 记账信息: 可能包括处理器时间总和，使用的时钟数总和，时间限制，记账号等。 其他信息
Linux下查看进程的方式 top ：Linux下的任务管理器，通常用来查看资源占用比较高的进程。对于查看某个进程的具体信息数据，使用ps更方便。 ps ：ps -ajx | head -1 &amp;&amp; ps -ajx | grep process_name while :; do ps axj | head -1 &amp;&amp; ps ajx | grep myproc | grep -v grep; sleep 1; done 循环进行ps查看进程，用于实时监控某个进程的信息。 /proc /proc 是Linux系统下的一个目录，存储着所有进程的信息。以每个进程的PID作为目录名来标识每个进程。 PID/PPID - 进程标示符 每个进程都有一个ID，PID就类似于人的身份证号码。而PPID是该进程的父进程的PID。]]></description>
</item>
<item>
    <title></title>
    <link>http://example.org/linux4_linux%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/</link>
    <pubDate>Mon, 01 Jan 0001 00:00:00 &#43;0000</pubDate>
    <author>xxxx</author>
    <guid>http://example.org/linux4_linux%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/</guid>
    <description><![CDATA[4_Linux进程控制 进程创建 fork创建子进程做了什么？ 进程 = 内核数据结构 + 进程的代码和数据 =&gt; 内核数据结构是操作系统创建的。而进程的代码和数据，一般是从磁盘中加载到内存而来。=&gt; fork创建子进程，由操作系统为子进程创建对应的内核数据结构：PCB，进程地址空间对象，页表等。虽然子进程内核数据结构中的大部分数据是从父进程那里拷贝来的，但是因为进程的独立性，这部分内核数据结构确实是子进程独有的。=&gt; 而子进程对应的代码和数据，并不是从磁盘中加载而来。而是直接和父进程”共享一份代码和数据“，可是，基于进程的独立性，父子进程共享一份代码和数据是如何实现的呢？=&gt; 对于代码：代码具有只读属性，也就是父子进程都不会修改，那么共享一份代码是完全可以的，同时这样还节省了内存空间 =&gt; 对于数据：事实上，子进程在创建初期，确实和父进程共享一份数据。
基于进程独立性，本身，父子进程的数据必须分离。那么在子进程创建初期，直接在内存中拷贝一份父进程的数据是完全可以的。 但是这样有很大的内存浪费的风险。=&gt; 父进程的数据，并非所有子进程都需要使用。 即使需要使用，也不会立刻使用。 即使立刻使用，也不一定是写操作。=&gt; 基于高效和节省内存空间的理念，我们不能采取直接拷贝一份父进程的数据。=&gt; 故我们在子进程创建时，是和父进程共享同一份数据。=&gt; 对于只读的，父子进程共享数据完全可以。对于父进程写的，或者子进程写的数据。基于进程独立性，必须进行数据分离。 操作系统采用的即 写时拷贝技术，来将父子进程数据分离。
进程调用fork，当控制转移到内核中的fork代码后，内核做：
分配新的内存块和内核数据结构给子进程 将父进程部分数据结构内容拷贝至子进程 添加子进程到系统进程列表当中 fork返回，开始调度器调度 父子进程分离数据的方式：写时拷贝 写时拷贝，在fork创建子进程这里的具体操作是：创建子进程之后，当父子进程的任何一方以写方式访问某个数据时，操作系统在内存的其他区域拷贝一份这个数据，并修改写此数据的那个进程的页表映射关系，使父子进程访问的是物理内存中的不同数据。以达到父子进程数据分离的效果，避免互相干扰。
写时拷贝好处： 在对数据进行写入时，再拷贝数据，是高效使用内存的一种表现，提高内存使用率，可以提高整机的运行效率。 写时拷贝还是一种延时申请的技术。提高内存使用率。
有关程序计数器和EIP寄存器： 一个事实：在fork创建子进程之后，父子进程的代码是共享的。那么为什么子进程是从fork内部的return或者说fork之后的代码开始执行呢？ 我们知道，子进程的创建是以父进程为模板的，比如大部分内核数据结构，代码，数据等。包括进程地址空间，页表。都是从父进程那里拷贝过来的。=&gt; 进程中的代码指令，每条代码指令都有地址，在CPU内部的寄存器中，有一个名为EIP的寄存器，称为程序计数器，Program Counter，简称PC。用于存放下一条需要执行的指令所在单元的地址。而CPU执行一个进程的代码指令就是依靠程序计数器。大致过程为：取指令（依据PC），分析指令（指令集架构ISA），执行指令。=&gt; 同时，进程并非一次就将全部的指令都执行完，而是执行若干时长，就需要切换为其他进程。切换前，之前的进程需要保存好程序计数器中的数据和其他相关数据。称为进程的上下文数据。以便下次切换为此进程时，可以继续上次CPU执行指令的进度。=&gt; 而fork创建子进程时，子进程的上下文数据都是从父进程那里拷贝过来的。所以，当子进程执行时，程序计数器中保存的指令地址致使子进程从父进程执行fork那里开始执行。同时fork之前的代码子进程是可见的，只是不是从头开始执行。
fork常规用法 一个父进程希望复制自己，使父子进程同时执行不同的代码段。例如，父进程等待客户端请求，生成子 进程来处理请求。
一个进程要执行一个不同的程序。例如子进程从fork返回后，调用exec函数。（比如OJ项目中，子进程通过execl来进行g++或者运行生成的可执行程序来获取运行结果）
fork什么时候会失败？ 系统中有太多的进程
实际用户的进程数超过了限制
vfork 创建一个子进程，共享同一个虚拟地址空间
进程终止 进程终止时，操作系统做了什么？ 释放进程相关内核数据结构和对应的代码和数据。 即释放进程占用的资源。
进程终止的分类情况 代码跑完，运行结果正确（符合预期）
代码跑完，运行结果不正确（不符合预期）
代码没有跑完，程序异常退出（崩溃）
进程退出码 进程退出码，是当进程执行结束后，用于标识运行结果的。 通常情况下，0标识success，非0标识结果不正确。 非零值有无数个，用不同的非零值来标识不同的错误原因。所以，依据进程退出码，可以判断上方情况的1 和 2 当进程异常退出时（崩溃），是由操作系统发送信号给进程以实现的。此时，退出码没有意义。 进程的退出码是返回给上一级进程（父进程）的，用于上一级进程获取该进程执行结果用的。（如果上一级进程不关心，则可以忽略） C语言中定义了一套将退出码/错误码转化为字符串描述的方案，你可以设定一套自己的用于程序中。strerror库函数可以查询C语言规定的退出码对应的退出原因。 Linux下，echo $?可查询上一个进程执行的退出码]]></description>
</item>
<item>
    <title></title>
    <link>http://example.org/linux5_gcc%E7%BC%96%E8%AF%91%E7%9A%84%E8%BF%87%E7%A8%8B%E5%8A%A8%E9%9D%99%E6%80%81%E5%BA%93/</link>
    <pubDate>Mon, 01 Jan 0001 00:00:00 &#43;0000</pubDate>
    <author>xxxx</author>
    <guid>http://example.org/linux5_gcc%E7%BC%96%E8%AF%91%E7%9A%84%E8%BF%87%E7%A8%8B%E5%8A%A8%E9%9D%99%E6%80%81%E5%BA%93/</guid>
    <description><![CDATA[C程序编译链接的过程 程序翻译的过程 源文件生成可执行程序的过程
1、预处理 预处理的作用/工作： 宏替换，头文件展开，条件编译，去注释。
1 2 3 4 5 6 7 8 [yzl@VM-4-5-centos testdir]$ ll total 4 -rw-rw-r-- 1 yzl yzl 314 Jul 30 17:14 test.c [yzl@VM-4-5-centos testdir]$ gcc -E test.c -o test.i [yzl@VM-4-5-centos testdir]$ ll total 24 -rw-rw-r-- 1 yzl yzl 314 Jul 30 17:14 test.c -rw-rw-r-- 1 yzl yzl 17030 Jul 30 17:15 test.i gcc -E test.c -o test.i 选项“-E”，该选项的作用是让 gcc 在预处理结束后停止编译过程。选项“-o”是指定目标文件,“.i”文件为已经过预处理的C原始程序。
上图中左边为预处理之后的test.i文件，可以看出预处理做了哪些操作。 即宏替换，头文件展开，条件编译，去注释。
2、编译 在这个阶段中,gcc 首先要检查代码的规范性、是否有语法错误等，以确定代码的实际要做的工作,在检查无误后]]></description>
</item>
<item>
    <title></title>
    <link>http://example.org/linux5_%E5%9F%BA%E7%A1%80io/</link>
    <pubDate>Mon, 01 Jan 0001 00:00:00 &#43;0000</pubDate>
    <author>xxxx</author>
    <guid>http://example.org/linux5_%E5%9F%BA%E7%A1%80io/</guid>
    <description><![CDATA[5_基础IO C标准库IO接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 int main() { FILE* fp = fopen(&#34;log.txt&#34;, &#34;w+&#34;); if(fp == NULL) { perror(&#34;fopen&#34;); return 1; } // C output fprintf(fp, &#34;hello fprintf\n&#34;); fputs(&#34;hello fputs\n&#34;, fp); fwrite(&#34;hello fwrite\n&#34;, strlen(&#34;hello fwrite\n&#34;), 1, fp); fclose(fp); fp = fopen(&#34;log.txt&#34;, &#34;r&#34;); char arr1[64]; char arr2[64]; char arr3[64]; fscanf(fp, &#34;%s&#34;, arr1); fgets(arr2, sizeof(arr2), fp); fread(arr3, sizeof(arr3), 1, fp); printf(&#34;%s&#34;, arr1); printf(&#34;%s&#34;, arr2); printf(&#34;%s&#34;, arr3); fclose(fp); return 0; } 打开文件fopen，关闭文件fclose，output输出类函数 fwrite fputs fprintf，intput输入类函数fread fscanf fgets]]></description>
</item>
<item>
    <title></title>
    <link>http://example.org/linux6_%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</link>
    <pubDate>Mon, 01 Jan 0001 00:00:00 &#43;0000</pubDate>
    <author>xxxx</author>
    <guid>http://example.org/linux6_%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</guid>
    <description><![CDATA[6_进程间通信 进程间通信的作用，应用场景，必要性 进程间通信，是建立在多进程之上的。如果是单进程，则无法利用并发能力，更加无法进行多进程协同。多进程要想实现多进程协同（目的），就必须进行进程间通信（手段）。
具体的进程间通信的目的（实例）：比如：1. 数据传输：一个进程需要将它的数据发送给另一个进程。2. 资源共享：多个进程之间共享同样的资源。 3. 通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。4. 进程控制：有些进程希望完全控制另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。
多进程通过进程间通信，比如具体的上方几个目的，实现多进程协同。（鉴于现在代码经验和知识的匮乏，可能无法切实理解到什么情况下需要多进程协同，但是这样的需求和场景肯定是存在的，需要后面不断的学习）
进程间通信的技术背景 进程是具有独立性的，这是在学习进程时，进程的一大特点。
进程 = 进程的内核数据结构 + 进程对应的代码和数据。不管是两个独立的进程，还是父进程fork创建子进程，进程的内核数据结构还有代码和数据都是有独立性的。因为虚拟地址空间+页表的存在，进程的虚拟地址通过页表映射到物理内存的不同区域，即使是父进程fork创建子进程，子进程的内核数据结构也会有独立的一份，而代码和数据在创建之初和父进程共享，但是因为写时拷贝技术的存在，子进程的代码和数据仍然是具有独立性的（比如，非常量全局数据，在父子进程之一写时，会拷贝一份。而代码，比如调用execl函数进行进程切换时，也会发生代码的写时拷贝）
因此，基于进程独立性，进程间如果想进行通信，成本是比较高的。
进程间通信的本质理解 因为进程是具有独立性的
所以，要想实现进程间通信，首先要让不同进程看到同一份资源（同一块&quot;内存&quot;，这个内存是特定的结构组织的），这个内存资源，不能隶属于任何一个进程，而更应该强调共享（其实就是属于操作系统管理的）
管道IPC：匿名管道 匿名管道的本质原理 在父进程fork创建子进程时，子进程会有自己独立的内核数据结构（如页表，虚拟地址空间，PCB，文件描述符表等），而这其中的文件描述符表中每一个元素存储的是该进程打开的所有文件对应的内核struct file结构体的地址。
当父进程fork创建子进程，子进程的大部分内核数据结构的数据都是从父进程那里直接拷贝过来的（包括虚拟地址空间，页表等），当然，部分字段还是需要修改的（如pid等），而其中的文件描述符表的数据是与父进程完全一致的。
因此，当父进程以读和写方式打开某一个文件之后，进行fork，子进程继承了父进程的文件描述符表，子进程也以读和写方式打开了这个文件。因为管道是单向通信的，故父子进程关闭自己不需要的一端之后，就可以通过该匿名管道文件进行通信。
demo示例代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 #include &lt;unistd.]]></description>
</item>
<item>
    <title></title>
    <link>http://example.org/linux7_%E8%BF%9B%E7%A8%8B%E4%BF%A1%E5%8F%B7/</link>
    <pubDate>Mon, 01 Jan 0001 00:00:00 &#43;0000</pubDate>
    <author>xxxx</author>
    <guid>http://example.org/linux7_%E8%BF%9B%E7%A8%8B%E4%BF%A1%E5%8F%B7/</guid>
    <description><![CDATA[7_进程信号 信号的基本认识 Linux信号机制：
它是一种异步的通知机制，用来提醒进程一个事件已经发生。
Linux操作系统中，有编号为1~31的31个普通信号，编号为34~64的31个实时信号，共62个信号。日常中只会涉及和使用到普通信号。故下方对信号的学习仅对于1~31的普通信号。
每个信号都有一个编号和一个宏定义名称，本质上，这些都是通过#define的形式定义的。也就是用一个int型变量去代替某特定信号。（编译之后，这些宏定义都会变为int整型）
进程处理信号的三种方式 信号的接收方一定是进程，因为信号就是OS用来提醒进程某个事件已经发生。故，进程在接收到信号之后，一定要处理这个信号。
执行该信号的默认处理动作。
忽略该信号。
提供一个信号处理函数，要求内核在处理该信号时切换到用户态执行这个处理函数，这种方式称为捕捉（Catch）一个信号。 （其实就是程序员自定义进程对某信号的处理方法，该方法存储在用户代码中）
简单来说就是默认，忽略，自定义捕捉。
信号产生：产生信号的若干种方式 1.通过键盘产生信号： ctrl + c：通过键盘组合键向前台进程发送2号SIGINT信号。
ctrl + \：通过键盘组合键向前台进程发送3号SIGQUIT信号。
理解：键盘是通过中断的方式工作的。输入某组合键-&gt;OS解释识别组合键-&gt;查找进程列表-&gt;前台运行的进程-&gt;OS将前台运行进程的PCB(task_struct)中的pending信号集位图中组合键对应的信号所对应的比特位由0置1（pending 信号集本质是一个位图结构，见信号保存。）（其实最后一步一句话就是：OS向前台进程发送对应信号，发送信号的本质就是如此）
有关前台进程与后台进程： Ctrl-C 产生的信号只能发给前台进程。一个命令后面加个&amp;可以放到后台运行（如 ./mysignal &amp;）,这样Shell不必等待进程 结束就可以接受新的命令,启动新的进程。Shell可以同时运行一个前台进程和任意多个后台进程,只有前台进程才能接到像 Ctrl-C 这种控制键产生的信号
前台进程在运行过程中用户随时可能按下 Ctrl-C 而产生一个信号,也就是说该进程的用户空间代码执行 到任何地方都有可能收到 SIGINT 信号而终止,所以信号相对于进程的控制流程来说是**异步(Asynchronous)**的。
2.通过系统调用接口产生信号： int kill(pid_t pid, int signo); 向指定进程发送指定信号
int raise(int signo); 向当前进程发送指定信号
void abort(void); 向当前进程发送6号SIGABRT信号
Linux还有一个kill命令，就是通过调用kill函数实现的。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 通过系统调用发送信号 void handler(int signo) { std::cout &lt;&lt; &#34;进程收到了一个&#34; &lt;&lt; signo &lt;&lt; &#34;号信号&#34; &lt;&lt; std::endl; } int main() { signal(2, handler); // 捕捉下方kill 和 raise发送的信号 signal(SIGABRT, handler); // 捕捉abort发送的6号SIGABRT信号 kill(getpid(), 2); raise(2); abort(); // 向当前进程发送SIGABRT信号，使其异常终止（默认） while(true) sleep(1); return 0; } 如上图，对6号SIGABRT信号明明捕捉了但是还是中止了。 这是一个很奇怪的现象，查了stack overflow：However, I cannot find any corroborating evidence of that behavior in the signal man page, which clearly states that The signals SIGKILL and SIGSTOP cannot be caught, blocked, or ignored but makes no similar mention for SIGABRT.]]></description>
</item>
<item>
    <title></title>
    <link>http://example.org/linux8.0_linux%E5%A4%9A%E7%BA%BF%E7%A8%8B/</link>
    <pubDate>Mon, 01 Jan 0001 00:00:00 &#43;0000</pubDate>
    <author>xxxx</author>
    <guid>http://example.org/linux8.0_linux%E5%A4%9A%E7%BA%BF%E7%A8%8B/</guid>
    <description><![CDATA[线程概念 线程在进程内部执行，是OS调度的基本单位。 线程是进程的一个执行分支，是在进程内部运行的一个执行流。 在一个程序里的一个执行路线就叫做线程（thread）。更准确的定义是：线程是“一个进程内部的控制序列”。 线程（英语：thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。 历史上，早期，操作系统中是没有线程的，也就是只有进程这个概念，一个进程内只有一个执行流。60年代，在OS中能拥有资源和独立运行的基本单位是进程，然而随着计算机技术的发展，进程出现了很多弊端，一是由于进程是资源拥有者，创建、撤消与切换存在较大的时空开销，因此需要引入轻型进程；二是由于对称多处理机（SMP）出现，可以满足多个运行单位，而多个进程并行开销过大。
因此在80年代，出现了能独立运行的基本单位——线程（Threads）。
线程有着自己的特点，比如执行粒度更细，更轻量化，调度切换的开销更小等等，而不同操作系统设计线程时有着不同的方案，Windows对于线程，设立了全新的数据结构，进程和线程划分的很清晰，这是比较复杂的。而因为线程创建，执行，切换，销毁等等很多行为都和进程有着很大的相似性，因此Linux采用了用进程模拟线程的设计方案（实现了进程内核代码的复用），这样的设计方案虽然没有为线程设计全新的数据结构，但是最终设计出的“轻量级进程”依旧符合线程的要求。
上图为学习线程之前，进程加载运行的示意图，每个进程都有一个task_struct（Linux），即进程PCB。
Linux线程的原理 Linux线程原理：OS内，如果我们创建“进程”时，不创建新的地址空间，用户级页表，不进行IO将程序的代码和数据加载到内存 只创建task_struct，让这个新的PCB指向旧的PCB（创建此新线程的主线程)指向的地址空间mm_struct，再通过一定的技术手段，将当前进程的资源合理划分给不同的task_struct，此时，这里的每一个task_struct，就称为一个线程。
线程在进程内部执行，指的是线程在进程的地址空间内运行。 每个进程内至少有一个执行线程（一个执行流） 在Linux系统中，在CPU眼中，看到的PCB都要比传统的进程的PCB更加轻量化，因此将Linux下的进程统一称之为轻量级进程。（多执行流时，PCB task_struct占用整个进程的一部分资源，当然轻量化） 之前一个进程，代码执行流程一定是按顺序执行的，多线程之后，就可以进行资源划分，所有线程共享一个地址空间，一个页表。此时的执行就由串型执行变为并发执行，效率更高。(??? 我们之前所写的程序为内部只有一个执行流的进程。而多线程即内部具有多个执行流的进程。 重新理解定义task_struct：进程内部的一个执行流（Linux下） CPU执行的基本单位是线程，OS调度的基本单位是线程。但并不是OS只能调度线程，实际上OS也是可以以进程整体为单位进行调度的。（见下方疑问） 重新理解进程的概念 如上红色区域即进程全部。
从用户视角来说：进程=内核数据结构+进程对应的代码和数据（内核数据结构中PCB的数量&gt;= 1）
从内核视角来说：进程：承担分配系统资源的基本实体。（因为在进程创建时，系统给这个进程分配资源。而线程是使用创建此线程的进程的部分资源，进程进行资源分配，分配给线程。故进程才是承担分配系统资源的基本实体）
疑问
对于线程这块我有个疑惑，既然CPU和OS调度的基本单位是线程，且一个进程内至少有一个执行线程（一个执行流），那能不能说CPU和OS只能调度线程呢，也就是理解为CPU调度一个单执行流进程时，本质上也是调度此进程内的一个执行线程？
一个CSDN链接，可供参考
调度是一方面，另一方面是调度的目的是什么。如果调度的目的是为了让执行流去执行，那肯定是让线程去跑。而如果目的是以进程整体为单位进行资源分配，则OS也是可以做到调度整个进程的。对于CPU来说，特别是Linux下，CPU并不关心线程还是进程，它只关心task_struct，因为在Linux下，只存在轻量级进程，不存在线程。只是用轻量级进程去模拟线程。
线程优缺点 线程的优点 创建一个新线程的代价要比创建一个新进程小得多（创建时的成本更小
与进程之间的切换相比，线程之间的切换需要操作系统做的工作要少很多（切换的成本更小
线程占用的资源要比进程少很多（占用的资源更少
能充分利用多处理器的可并行数量（并行
在等待慢速I/O操作结束的同时，程序可执行其他的计算任务
计算密集型应用，为了能在多处理器系统上运行，将计算分解到多个线程中实现
I/O密集型应用，为了提高性能，将I/O操作重叠。线程可以同时等待不同的I/O操作。
线程的缺点 性能损失 一个很少被外部事件阻塞的计算密集型线程往往无法与其它线程共享同一个处理器。如果计算密集型线程的数量比可用的处理器多，那么可能会有较大的性能损失，这里的性能损失指的是增加了额外的同步和调度开销，而可用的资源不变。
健壮性降低 编写多线程需要更全面更深入的考虑，在一个多线程程序里，因时间分配上的细微偏差或者因共享了不该共享的变量而造成不良影响的可能性是很大的，换句话说线程之间是缺乏保护的。
缺乏访问控制 进程是访问控制的基本粒度，在一个线程中调用某些OS函数会对整个进程造成影响。
编程难度提高 编写与调试一个多线程程序比单线程程序困难得多
线程异常 单个线程如果出现除零，野指针问题导致线程崩溃，进程也会随着崩溃
线程是进程的执行分支，线程出异常，就类似进程出异常，进而触发信号机制，终止进程，进程终止，该进程内的所有线程也就随即退出
线程用途 合理的使用多线程，能提高CPU密集型程序的执行效率
合理的使用多线程，能提高IO密集型程序的用户体验（如生活中我们一边写代码一边下载开发工具，就是 多线程运行的一种表现）
进程vs线程 进程是资源分配的基本单位
线程是调度的基本单位。
线程共享进程内的部分数据 **进程内的所有线程共享同一个进程地址空间，则其中的代码区，全局数据区，共享区，命令行参数和环境变量，内核区都是共享的。**而对于堆区和栈区，根本上来说是共享的，因为一个线程可以将栈帧内的局部数据或堆区开辟空间的地址通过全局数据的方式传递给其他线程，其他线程也可以访问。但是一般情况下我们不会这样做，所以也可以认为栈区和堆区是线程私有的。
除此之外，各线程还共享进程内的文件描述符表（一个线程打开一个文件，其他线程也会自动打开），各种信号的处理方式（SIG_IGN，SIG_DFL或者自定义的信号处理函数（代码区）），当前工作目录，用户id和组id等&hellip;
属于线程自己的一部分数据 线程id，errno，信号屏蔽字，调度优先级。
最重要的是：每个线程私有 一组寄存器和栈。
一组寄存器：线程是CPU调度的基本单位，每个线程一定有自己的上下文。在线程被CPU调度时，上下文数据就会保存在CPU内的一组寄存器中。
栈：每个线程运行时要调用函数，一定有出栈入栈的行为，形成的临时变量会保存在栈内，故每个线程必须有自己的私有栈。
一组寄存器和栈能体现出线程的动态属性。
验证每个线程有独立的信号屏蔽字
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;thread&gt; #include &lt;signal.]]></description>
</item>
<item>
    <title></title>
    <link>http://example.org/linux8.1_%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/</link>
    <pubDate>Mon, 01 Jan 0001 00:00:00 &#43;0000</pubDate>
    <author>xxxx</author>
    <guid>http://example.org/linux8.1_%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/</guid>
    <description><![CDATA[线程互斥 线程互斥及相关概念 **线程互斥（Mutual Exclusion）**是指在多线程环境下，同一时刻只能有一个线程访问共享资源，以避免对该资源的不正确访问，造成数据不一致等问题。 例如，如果有多个线程都要同时对同一个全局变量进行修改，那么就需要使用线程互斥来保证对该变量的访问是互斥的，也就是说，在任意时刻只能有一个线程对该变量进行访问。
**临界资源（Critical Resource）**是指在多线程环境下需要被多个线程共享访问的资源，对该资源的访问需要进行同步（如使用互斥进行同步）以避免出现不正确的访问。
临界区：每个线程内部，访问临界资源的代码，就叫做临界区
互斥：任何时刻，互斥保证有且只有一个执行流进入临界区，访问临界资源，通常对临界资源起保护作用。是对临界资源保护的一种手段。
原子性：不会被任何调度机制影响的操作，该操作只有两态，要么完成，要么未完成。
互斥量mutex： 大部分情况，线程使用的数据都是局部变量，变量的地址空间在线程栈空间内，这种情况，变量归属单个线程，其他线程无法获得这种变量。 但有时候，很多变量都需要在线程间共享，这样的变量称为共享变量，可以通过数据的共享，完成线程之间的交互。 多个线程并发的操作共享变量，会带来一些问题。
多线程抢票 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include &lt;iostream&gt; #include &lt;pthread.h&gt; #include &lt;string&gt; #include &lt;unistd.]]></description>
</item>
</channel>
</rss>
